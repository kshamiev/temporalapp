// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	go go1.22.2
//	protoc major:4 minor:25 patch:1 suffix:""
//
// source: checkout.proto
package temporal

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"time"
)

// CheckoutTaskQueue is the default task-queue for a temporal.Checkout worker
const CheckoutTaskQueue = "general"

// temporal.Checkout workflow names
const (
	CheckoutFlowWorkflowName = "temporal.Checkout.CheckoutFlow"
)

// temporal.Checkout workflow id expressions
var (
	CheckoutFlowIdexpression = expression.MustParseExpression("checkout/${! id.or(uuid_v4()) }")
)

// temporal.Checkout activity names
const (
	AssortmentReserveActivityName       = "temporal.Checkout.AssortmentReserve"
	AssortmentReserveCancelActivityName = "temporal.Checkout.AssortmentReserveCancel"
	CreatePaymentActivityName           = "temporal.Checkout.CreatePayment"
	PaymentCancelActivityName           = "temporal.Checkout.PaymentCancel"
)

// CheckoutClient describes a client for a(n) temporal.Checkout worker
type CheckoutClient interface {
	// CheckoutFlow executes a(n) temporal.Checkout.CheckoutFlow workflow and blocks until error or response received
	CheckoutFlow(ctx context.Context, req *CheckoutFlowRequest, opts ...*CheckoutFlowOptions) (*Order, error)

	// CheckoutFlowAsync starts a(n) temporal.Checkout.CheckoutFlow workflow and returns a handle to the workflow run
	CheckoutFlowAsync(ctx context.Context, req *CheckoutFlowRequest, opts ...*CheckoutFlowOptions) (CheckoutFlowRun, error)

	// GetCheckoutFlow retrieves a handle to an existing temporal.Checkout.CheckoutFlow workflow execution
	GetCheckoutFlow(ctx context.Context, workflowID string, runID string) CheckoutFlowRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// checkoutClient implements a temporal client for a temporal.Checkout service
type checkoutClient struct {
	client client.Client
	log    *slog.Logger
}

// NewCheckoutClient initializes a new temporal.Checkout client
func NewCheckoutClient(c client.Client, options ...*checkoutClientOptions) CheckoutClient {
	var cfg *checkoutClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewCheckoutClientOptions()
	}
	return &checkoutClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewCheckoutClientWithOptions initializes a new Checkout client with the given options
func NewCheckoutClientWithOptions(c client.Client, opts client.Options, options ...*checkoutClientOptions) (CheckoutClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *checkoutClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewCheckoutClientOptions()
	}
	return &checkoutClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// checkoutClientOptions describes optional runtime configuration for a CheckoutClient
type checkoutClientOptions struct {
	log *slog.Logger
}

// NewCheckoutClientOptions initializes a new checkoutClientOptions value
func NewCheckoutClientOptions() *checkoutClientOptions {
	return &checkoutClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *checkoutClientOptions) WithLogger(l *slog.Logger) *checkoutClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *checkoutClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// temporal.Checkout.CheckoutFlow executes a temporal.Checkout.CheckoutFlow workflow and blocks until error or response received
func (c *checkoutClient) CheckoutFlow(ctx context.Context, req *CheckoutFlowRequest, options ...*CheckoutFlowOptions) (*Order, error) {
	run, err := c.CheckoutFlowAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CheckoutFlowAsync starts a(n) temporal.Checkout.CheckoutFlow workflow and returns a handle to the workflow run
func (c *checkoutClient) CheckoutFlowAsync(ctx context.Context, req *CheckoutFlowRequest, options ...*CheckoutFlowOptions) (CheckoutFlowRun, error) {
	var o *CheckoutFlowOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCheckoutFlowOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, CheckoutFlowWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &checkoutFlowRun{
		client: c,
		run:    run,
	}, nil
}

// GetCheckoutFlow fetches an existing temporal.Checkout.CheckoutFlow execution
func (c *checkoutClient) GetCheckoutFlow(ctx context.Context, workflowID string, runID string) CheckoutFlowRun {
	return &checkoutFlowRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *checkoutClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *checkoutClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// CheckoutFlowOptions provides configuration for a temporal.Checkout.CheckoutFlow workflow operation
type CheckoutFlowOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewCheckoutFlowOptions initializes a new CheckoutFlowOptions value
func NewCheckoutFlowOptions() *CheckoutFlowOptions {
	return &CheckoutFlowOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *CheckoutFlowOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(CheckoutFlowIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", CheckoutFlowWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	} else if opts.WorkflowIDReusePolicy == enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = enumsv1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = CheckoutTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *CheckoutFlowOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *CheckoutFlowOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CheckoutFlowOptions) WithExecutionTimeout(d time.Duration) *CheckoutFlowOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *CheckoutFlowOptions) WithID(id string) *CheckoutFlowOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CheckoutFlowOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CheckoutFlowOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CheckoutFlowOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CheckoutFlowOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CheckoutFlowOptions) WithRunTimeout(d time.Duration) *CheckoutFlowOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CheckoutFlowOptions) WithSearchAttributes(sa map[string]any) *CheckoutFlowOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CheckoutFlowOptions) WithTaskTimeout(d time.Duration) *CheckoutFlowOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CheckoutFlowOptions) WithTaskQueue(tq string) *CheckoutFlowOptions {
	o.taskQueue = &tq
	return o
}

// CheckoutFlowRun describes a(n) temporal.Checkout.CheckoutFlow workflow run
type CheckoutFlowRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*Order, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// checkoutFlowRun provides an internal implementation of a(n) CheckoutFlowRunRun
type checkoutFlowRun struct {
	client *checkoutClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *checkoutFlowRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *checkoutFlowRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *checkoutFlowRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *checkoutFlowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *checkoutFlowRun) Get(ctx context.Context) (*Order, error) {
	var resp Order
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *checkoutFlowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// CheckoutFlowFunction implements a "temporal.Checkout.CheckoutFlow" workflow
	CheckoutFlowFunction func(workflow.Context, *CheckoutFlowRequest) (*Order, error)
)

// CheckoutWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// CheckoutWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	CheckoutWorkflowFunctions interface {
		// CheckoutFlow executes a "temporal.Checkout.CheckoutFlow" workflow inline
		CheckoutFlow(workflow.Context, *CheckoutFlowRequest) (*Order, error)
	}
	// checkoutWorkflowFunctions provides an internal CheckoutWorkflowFunctions implementation
	checkoutWorkflowFunctions struct{}
)

func NewCheckoutWorkflowFunctions() CheckoutWorkflowFunctions {
	return &checkoutWorkflowFunctions{}
}

// CheckoutFlow executes a "temporal.Checkout.CheckoutFlow" workflow inline
func (f *checkoutWorkflowFunctions) CheckoutFlow(ctx workflow.Context, req *CheckoutFlowRequest) (*Order, error) {
	if CheckoutFlowFunction == nil {
		return nil, errors.New("CheckoutFlow requires workflow registration via RegisterCheckoutWorkflows or RegisterCheckoutFlowWorkflow")
	}
	return CheckoutFlowFunction(ctx, req)
}

// CheckoutWorkflows provides methods for initializing new temporal.Checkout workflow values
type CheckoutWorkflows interface {
	// CheckoutFlow initializes a new a(n) CheckoutFlowWorkflow implementation
	CheckoutFlow(ctx workflow.Context, input *CheckoutFlowWorkflowInput) (CheckoutFlowWorkflow, error)
}

// RegisterCheckoutWorkflows registers temporal.Checkout workflows with the given worker
func RegisterCheckoutWorkflows(r worker.WorkflowRegistry, workflows CheckoutWorkflows) {
	RegisterCheckoutFlowWorkflow(r, workflows.CheckoutFlow)
}

// RegisterCheckoutFlowWorkflow registers a temporal.Checkout.CheckoutFlow workflow with the given worker
func RegisterCheckoutFlowWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *CheckoutFlowWorkflowInput) (CheckoutFlowWorkflow, error)) {
	CheckoutFlowFunction = buildCheckoutFlow(wf)
	r.RegisterWorkflowWithOptions(CheckoutFlowFunction, workflow.RegisterOptions{Name: CheckoutFlowWorkflowName})
}

// buildCheckoutFlow converts a CheckoutFlow workflow struct into a valid workflow function
func buildCheckoutFlow(ctor func(workflow.Context, *CheckoutFlowWorkflowInput) (CheckoutFlowWorkflow, error)) func(workflow.Context, *CheckoutFlowRequest) (*Order, error) {
	return func(ctx workflow.Context, req *CheckoutFlowRequest) (*Order, error) {
		input := &CheckoutFlowWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// CheckoutFlowWorkflowInput describes the input to a(n) temporal.Checkout.CheckoutFlow workflow constructor
type CheckoutFlowWorkflowInput struct {
	Req *CheckoutFlowRequest
}

// CheckoutFlowWorkflow describes a(n) temporal.Checkout.CheckoutFlow workflow implementation
//
// workflow details: (id: "checkout/${! id.or(uuid_v4()) }")
type CheckoutFlowWorkflow interface {
	// Execute defines the entrypoint to a(n) temporal.Checkout.CheckoutFlow workflow
	Execute(ctx workflow.Context) (*Order, error)
}

// CheckoutFlowChild executes a child temporal.Checkout.CheckoutFlow workflow and blocks until error or response received
func CheckoutFlowChild(ctx workflow.Context, req *CheckoutFlowRequest, options ...*CheckoutFlowChildOptions) (*Order, error) {
	childRun, err := CheckoutFlowChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// CheckoutFlowChildAsync starts a child temporal.Checkout.CheckoutFlow workflow and returns a handle to the child workflow run
func CheckoutFlowChildAsync(ctx workflow.Context, req *CheckoutFlowRequest, options ...*CheckoutFlowChildOptions) (*CheckoutFlowChildRun, error) {
	var o *CheckoutFlowChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCheckoutFlowChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &CheckoutFlowChildRun{Future: workflow.ExecuteChildWorkflow(ctx, CheckoutFlowWorkflowName, req)}, nil
}

// CheckoutFlowChildOptions provides configuration for a child temporal.Checkout.CheckoutFlow workflow operation
type CheckoutFlowChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewCheckoutFlowChildOptions initializes a new CheckoutFlowChildOptions value
func NewCheckoutFlowChildOptions() *CheckoutFlowChildOptions {
	return &CheckoutFlowChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *CheckoutFlowChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(CheckoutFlowIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", CheckoutFlowWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", CheckoutFlowWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(CheckoutFlowIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", CheckoutFlowWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	} else if opts.WorkflowIDReusePolicy == enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = enumsv1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = CheckoutTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *CheckoutFlowChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *CheckoutFlowChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CheckoutFlowChildOptions) WithExecutionTimeout(d time.Duration) *CheckoutFlowChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *CheckoutFlowChildOptions) WithID(id string) *CheckoutFlowChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CheckoutFlowChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CheckoutFlowChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *CheckoutFlowChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *CheckoutFlowChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CheckoutFlowChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CheckoutFlowChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CheckoutFlowChildOptions) WithRunTimeout(d time.Duration) *CheckoutFlowChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CheckoutFlowChildOptions) WithSearchAttributes(sa map[string]any) *CheckoutFlowChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CheckoutFlowChildOptions) WithTaskTimeout(d time.Duration) *CheckoutFlowChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CheckoutFlowChildOptions) WithTaskQueue(tq string) *CheckoutFlowChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *CheckoutFlowChildOptions) WithWaitForCancellation(wait bool) *CheckoutFlowChildOptions {
	o.waitForCancellation = &wait
	return o
}

// CheckoutFlowChildRun describes a child CheckoutFlow workflow run
type CheckoutFlowChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *CheckoutFlowChildRun) Get(ctx workflow.Context) (*Order, error) {
	var resp Order
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *CheckoutFlowChildRun) Select(sel workflow.Selector, fn func(*CheckoutFlowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *CheckoutFlowChildRun) SelectStart(sel workflow.Selector, fn func(*CheckoutFlowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *CheckoutFlowChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// CheckoutActivities describes available worker activities
type CheckoutActivities interface {
	// temporal.Checkout.AssortmentReserve implements a(n) temporal.Checkout.AssortmentReserve activity definition
	AssortmentReserve(ctx context.Context, req *AssortmentReserveRequest) error

	// temporal.Checkout.AssortmentReserveCancel implements a(n) temporal.Checkout.AssortmentReserveCancel activity definition
	AssortmentReserveCancel(ctx context.Context, req *AssortmentReserveRequest) error

	// temporal.Checkout.CreatePayment implements a(n) temporal.Checkout.CreatePayment activity definition
	CreatePayment(ctx context.Context, req *CreatePaymentRequest) (*CreatePaymentResponse, error)

	// temporal.Checkout.PaymentCancel implements a(n) temporal.Checkout.PaymentCancel activity definition
	PaymentCancel(ctx context.Context, req *PaymentCancelRequest) error
}

// RegisterCheckoutActivities registers activities with a worker
func RegisterCheckoutActivities(r worker.ActivityRegistry, activities CheckoutActivities) {
	RegisterAssortmentReserveActivity(r, activities.AssortmentReserve)
	RegisterAssortmentReserveCancelActivity(r, activities.AssortmentReserveCancel)
	RegisterCreatePaymentActivity(r, activities.CreatePayment)
	RegisterPaymentCancelActivity(r, activities.PaymentCancel)
}

// RegisterAssortmentReserveActivity registers a temporal.Checkout.AssortmentReserve activity
func RegisterAssortmentReserveActivity(r worker.ActivityRegistry, fn func(context.Context, *AssortmentReserveRequest) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: AssortmentReserveActivityName,
	})
}

// AssortmentReserveFuture describes a(n) temporal.Checkout.AssortmentReserve activity execution
type AssortmentReserveFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *AssortmentReserveFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *AssortmentReserveFuture) Select(sel workflow.Selector, fn func(*AssortmentReserveFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// AssortmentReserve executes a(n) temporal.Checkout.AssortmentReserve activity
func AssortmentReserve(ctx workflow.Context, req *AssortmentReserveRequest, options ...*AssortmentReserveActivityOptions) error {
	return AssortmentReserveAsync(ctx, req, options...).Get(ctx)
}

// AssortmentReserveAsync executes a(n) temporal.Checkout.AssortmentReserve activity (asynchronously)
func AssortmentReserveAsync(ctx workflow.Context, req *AssortmentReserveRequest, options ...*AssortmentReserveActivityOptions) *AssortmentReserveFuture {
	var o *AssortmentReserveActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewAssortmentReserveActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &AssortmentReserveFuture{Future: errF}
	}
	activity := AssortmentReserveActivityName
	future := &AssortmentReserveFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// AssortmentReserveLocal executes a(n) temporal.Checkout.AssortmentReserve activity (locally)
func AssortmentReserveLocal(ctx workflow.Context, req *AssortmentReserveRequest, options ...*AssortmentReserveLocalActivityOptions) error {
	return AssortmentReserveLocalAsync(ctx, req, options...).Get(ctx)
}

// AssortmentReserveLocalAsync executes a(n) temporal.Checkout.AssortmentReserve activity (asynchronously, locally)
func AssortmentReserveLocalAsync(ctx workflow.Context, req *AssortmentReserveRequest, options ...*AssortmentReserveLocalActivityOptions) *AssortmentReserveFuture {
	var o *AssortmentReserveLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewAssortmentReserveLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &AssortmentReserveFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = AssortmentReserveActivityName
	}
	future := &AssortmentReserveFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// AssortmentReserveActivityOptions provides configuration for a(n) temporal.Checkout.AssortmentReserve activity
type AssortmentReserveActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewAssortmentReserveActivityOptions initializes a new AssortmentReserveActivityOptions value
func NewAssortmentReserveActivityOptions() *AssortmentReserveActivityOptions {
	return &AssortmentReserveActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *AssortmentReserveActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 4000000000 // 4 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = CheckoutTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *AssortmentReserveActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *AssortmentReserveActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *AssortmentReserveActivityOptions) WithHeartbeatTimeout(d time.Duration) *AssortmentReserveActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *AssortmentReserveActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *AssortmentReserveActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *AssortmentReserveActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *AssortmentReserveActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *AssortmentReserveActivityOptions) WithScheduleToStartTimeout(d time.Duration) *AssortmentReserveActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *AssortmentReserveActivityOptions) WithStartToCloseTimeout(d time.Duration) *AssortmentReserveActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *AssortmentReserveActivityOptions) WithTaskQueue(tq string) *AssortmentReserveActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *AssortmentReserveActivityOptions) WithWaitForCancellation(wait bool) *AssortmentReserveActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// AssortmentReserveLocalActivityOptions provides configuration for a(n) temporal.Checkout.AssortmentReserve activity
type AssortmentReserveLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *AssortmentReserveRequest) error
}

// NewAssortmentReserveLocalActivityOptions initializes a new AssortmentReserveLocalActivityOptions value
func NewAssortmentReserveLocalActivityOptions() *AssortmentReserveLocalActivityOptions {
	return &AssortmentReserveLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *AssortmentReserveLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 4000000000 // 4 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom temporal.Checkout.AssortmentReserve implementation
func (o *AssortmentReserveLocalActivityOptions) Local(fn func(context.Context, *AssortmentReserveRequest) error) *AssortmentReserveLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *AssortmentReserveLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *AssortmentReserveLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *AssortmentReserveLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *AssortmentReserveLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *AssortmentReserveLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *AssortmentReserveLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *AssortmentReserveLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *AssortmentReserveLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterAssortmentReserveCancelActivity registers a temporal.Checkout.AssortmentReserveCancel activity
func RegisterAssortmentReserveCancelActivity(r worker.ActivityRegistry, fn func(context.Context, *AssortmentReserveRequest) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: AssortmentReserveCancelActivityName,
	})
}

// AssortmentReserveCancelFuture describes a(n) temporal.Checkout.AssortmentReserveCancel activity execution
type AssortmentReserveCancelFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *AssortmentReserveCancelFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *AssortmentReserveCancelFuture) Select(sel workflow.Selector, fn func(*AssortmentReserveCancelFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// AssortmentReserveCancel executes a(n) temporal.Checkout.AssortmentReserveCancel activity
func AssortmentReserveCancel(ctx workflow.Context, req *AssortmentReserveRequest, options ...*AssortmentReserveCancelActivityOptions) error {
	return AssortmentReserveCancelAsync(ctx, req, options...).Get(ctx)
}

// AssortmentReserveCancelAsync executes a(n) temporal.Checkout.AssortmentReserveCancel activity (asynchronously)
func AssortmentReserveCancelAsync(ctx workflow.Context, req *AssortmentReserveRequest, options ...*AssortmentReserveCancelActivityOptions) *AssortmentReserveCancelFuture {
	var o *AssortmentReserveCancelActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewAssortmentReserveCancelActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &AssortmentReserveCancelFuture{Future: errF}
	}
	activity := AssortmentReserveCancelActivityName
	future := &AssortmentReserveCancelFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// AssortmentReserveCancelLocal executes a(n) temporal.Checkout.AssortmentReserveCancel activity (locally)
func AssortmentReserveCancelLocal(ctx workflow.Context, req *AssortmentReserveRequest, options ...*AssortmentReserveCancelLocalActivityOptions) error {
	return AssortmentReserveCancelLocalAsync(ctx, req, options...).Get(ctx)
}

// AssortmentReserveCancelLocalAsync executes a(n) temporal.Checkout.AssortmentReserveCancel activity (asynchronously, locally)
func AssortmentReserveCancelLocalAsync(ctx workflow.Context, req *AssortmentReserveRequest, options ...*AssortmentReserveCancelLocalActivityOptions) *AssortmentReserveCancelFuture {
	var o *AssortmentReserveCancelLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewAssortmentReserveCancelLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &AssortmentReserveCancelFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = AssortmentReserveCancelActivityName
	}
	future := &AssortmentReserveCancelFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// AssortmentReserveCancelActivityOptions provides configuration for a(n) temporal.Checkout.AssortmentReserveCancel activity
type AssortmentReserveCancelActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewAssortmentReserveCancelActivityOptions initializes a new AssortmentReserveCancelActivityOptions value
func NewAssortmentReserveCancelActivityOptions() *AssortmentReserveCancelActivityOptions {
	return &AssortmentReserveCancelActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *AssortmentReserveCancelActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 4000000000 // 4 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = CheckoutTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *AssortmentReserveCancelActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *AssortmentReserveCancelActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *AssortmentReserveCancelActivityOptions) WithHeartbeatTimeout(d time.Duration) *AssortmentReserveCancelActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *AssortmentReserveCancelActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *AssortmentReserveCancelActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *AssortmentReserveCancelActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *AssortmentReserveCancelActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *AssortmentReserveCancelActivityOptions) WithScheduleToStartTimeout(d time.Duration) *AssortmentReserveCancelActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *AssortmentReserveCancelActivityOptions) WithStartToCloseTimeout(d time.Duration) *AssortmentReserveCancelActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *AssortmentReserveCancelActivityOptions) WithTaskQueue(tq string) *AssortmentReserveCancelActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *AssortmentReserveCancelActivityOptions) WithWaitForCancellation(wait bool) *AssortmentReserveCancelActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// AssortmentReserveCancelLocalActivityOptions provides configuration for a(n) temporal.Checkout.AssortmentReserveCancel activity
type AssortmentReserveCancelLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *AssortmentReserveRequest) error
}

// NewAssortmentReserveCancelLocalActivityOptions initializes a new AssortmentReserveCancelLocalActivityOptions value
func NewAssortmentReserveCancelLocalActivityOptions() *AssortmentReserveCancelLocalActivityOptions {
	return &AssortmentReserveCancelLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *AssortmentReserveCancelLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 4000000000 // 4 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom temporal.Checkout.AssortmentReserveCancel implementation
func (o *AssortmentReserveCancelLocalActivityOptions) Local(fn func(context.Context, *AssortmentReserveRequest) error) *AssortmentReserveCancelLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *AssortmentReserveCancelLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *AssortmentReserveCancelLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *AssortmentReserveCancelLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *AssortmentReserveCancelLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *AssortmentReserveCancelLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *AssortmentReserveCancelLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *AssortmentReserveCancelLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *AssortmentReserveCancelLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterCreatePaymentActivity registers a temporal.Checkout.CreatePayment activity
func RegisterCreatePaymentActivity(r worker.ActivityRegistry, fn func(context.Context, *CreatePaymentRequest) (*CreatePaymentResponse, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: CreatePaymentActivityName,
	})
}

// CreatePaymentFuture describes a(n) temporal.Checkout.CreatePayment activity execution
type CreatePaymentFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *CreatePaymentFuture) Get(ctx workflow.Context) (*CreatePaymentResponse, error) {
	var resp CreatePaymentResponse
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *CreatePaymentFuture) Select(sel workflow.Selector, fn func(*CreatePaymentFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// CreatePayment executes a(n) temporal.Checkout.CreatePayment activity
func CreatePayment(ctx workflow.Context, req *CreatePaymentRequest, options ...*CreatePaymentActivityOptions) (*CreatePaymentResponse, error) {
	return CreatePaymentAsync(ctx, req, options...).Get(ctx)
}

// CreatePaymentAsync executes a(n) temporal.Checkout.CreatePayment activity (asynchronously)
func CreatePaymentAsync(ctx workflow.Context, req *CreatePaymentRequest, options ...*CreatePaymentActivityOptions) *CreatePaymentFuture {
	var o *CreatePaymentActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCreatePaymentActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &CreatePaymentFuture{Future: errF}
	}
	activity := CreatePaymentActivityName
	future := &CreatePaymentFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// CreatePaymentLocal executes a(n) temporal.Checkout.CreatePayment activity (locally)
func CreatePaymentLocal(ctx workflow.Context, req *CreatePaymentRequest, options ...*CreatePaymentLocalActivityOptions) (*CreatePaymentResponse, error) {
	return CreatePaymentLocalAsync(ctx, req, options...).Get(ctx)
}

// CreatePaymentLocalAsync executes a(n) temporal.Checkout.CreatePayment activity (asynchronously, locally)
func CreatePaymentLocalAsync(ctx workflow.Context, req *CreatePaymentRequest, options ...*CreatePaymentLocalActivityOptions) *CreatePaymentFuture {
	var o *CreatePaymentLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCreatePaymentLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &CreatePaymentFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = CreatePaymentActivityName
	}
	future := &CreatePaymentFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// CreatePaymentActivityOptions provides configuration for a(n) temporal.Checkout.CreatePayment activity
type CreatePaymentActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewCreatePaymentActivityOptions initializes a new CreatePaymentActivityOptions value
func NewCreatePaymentActivityOptions() *CreatePaymentActivityOptions {
	return &CreatePaymentActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *CreatePaymentActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 4000000000 // 4 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = CheckoutTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *CreatePaymentActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *CreatePaymentActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *CreatePaymentActivityOptions) WithHeartbeatTimeout(d time.Duration) *CreatePaymentActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CreatePaymentActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CreatePaymentActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *CreatePaymentActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *CreatePaymentActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *CreatePaymentActivityOptions) WithScheduleToStartTimeout(d time.Duration) *CreatePaymentActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *CreatePaymentActivityOptions) WithStartToCloseTimeout(d time.Duration) *CreatePaymentActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CreatePaymentActivityOptions) WithTaskQueue(tq string) *CreatePaymentActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *CreatePaymentActivityOptions) WithWaitForCancellation(wait bool) *CreatePaymentActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// CreatePaymentLocalActivityOptions provides configuration for a(n) temporal.Checkout.CreatePayment activity
type CreatePaymentLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *CreatePaymentRequest) (*CreatePaymentResponse, error)
}

// NewCreatePaymentLocalActivityOptions initializes a new CreatePaymentLocalActivityOptions value
func NewCreatePaymentLocalActivityOptions() *CreatePaymentLocalActivityOptions {
	return &CreatePaymentLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *CreatePaymentLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 4000000000 // 4 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom temporal.Checkout.CreatePayment implementation
func (o *CreatePaymentLocalActivityOptions) Local(fn func(context.Context, *CreatePaymentRequest) (*CreatePaymentResponse, error)) *CreatePaymentLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *CreatePaymentLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *CreatePaymentLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CreatePaymentLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CreatePaymentLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *CreatePaymentLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *CreatePaymentLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *CreatePaymentLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *CreatePaymentLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterPaymentCancelActivity registers a temporal.Checkout.PaymentCancel activity
func RegisterPaymentCancelActivity(r worker.ActivityRegistry, fn func(context.Context, *PaymentCancelRequest) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: PaymentCancelActivityName,
	})
}

// PaymentCancelFuture describes a(n) temporal.Checkout.PaymentCancel activity execution
type PaymentCancelFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *PaymentCancelFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *PaymentCancelFuture) Select(sel workflow.Selector, fn func(*PaymentCancelFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// PaymentCancel executes a(n) temporal.Checkout.PaymentCancel activity
func PaymentCancel(ctx workflow.Context, req *PaymentCancelRequest, options ...*PaymentCancelActivityOptions) error {
	return PaymentCancelAsync(ctx, req, options...).Get(ctx)
}

// PaymentCancelAsync executes a(n) temporal.Checkout.PaymentCancel activity (asynchronously)
func PaymentCancelAsync(ctx workflow.Context, req *PaymentCancelRequest, options ...*PaymentCancelActivityOptions) *PaymentCancelFuture {
	var o *PaymentCancelActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPaymentCancelActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &PaymentCancelFuture{Future: errF}
	}
	activity := PaymentCancelActivityName
	future := &PaymentCancelFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// PaymentCancelLocal executes a(n) temporal.Checkout.PaymentCancel activity (locally)
func PaymentCancelLocal(ctx workflow.Context, req *PaymentCancelRequest, options ...*PaymentCancelLocalActivityOptions) error {
	return PaymentCancelLocalAsync(ctx, req, options...).Get(ctx)
}

// PaymentCancelLocalAsync executes a(n) temporal.Checkout.PaymentCancel activity (asynchronously, locally)
func PaymentCancelLocalAsync(ctx workflow.Context, req *PaymentCancelRequest, options ...*PaymentCancelLocalActivityOptions) *PaymentCancelFuture {
	var o *PaymentCancelLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPaymentCancelLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &PaymentCancelFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = PaymentCancelActivityName
	}
	future := &PaymentCancelFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// PaymentCancelActivityOptions provides configuration for a(n) temporal.Checkout.PaymentCancel activity
type PaymentCancelActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewPaymentCancelActivityOptions initializes a new PaymentCancelActivityOptions value
func NewPaymentCancelActivityOptions() *PaymentCancelActivityOptions {
	return &PaymentCancelActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *PaymentCancelActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 4000000000 // 4 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = CheckoutTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *PaymentCancelActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *PaymentCancelActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *PaymentCancelActivityOptions) WithHeartbeatTimeout(d time.Duration) *PaymentCancelActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *PaymentCancelActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *PaymentCancelActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *PaymentCancelActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *PaymentCancelActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *PaymentCancelActivityOptions) WithScheduleToStartTimeout(d time.Duration) *PaymentCancelActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *PaymentCancelActivityOptions) WithStartToCloseTimeout(d time.Duration) *PaymentCancelActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *PaymentCancelActivityOptions) WithTaskQueue(tq string) *PaymentCancelActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *PaymentCancelActivityOptions) WithWaitForCancellation(wait bool) *PaymentCancelActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// PaymentCancelLocalActivityOptions provides configuration for a(n) temporal.Checkout.PaymentCancel activity
type PaymentCancelLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *PaymentCancelRequest) error
}

// NewPaymentCancelLocalActivityOptions initializes a new PaymentCancelLocalActivityOptions value
func NewPaymentCancelLocalActivityOptions() *PaymentCancelLocalActivityOptions {
	return &PaymentCancelLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *PaymentCancelLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 4000000000 // 4 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom temporal.Checkout.PaymentCancel implementation
func (o *PaymentCancelLocalActivityOptions) Local(fn func(context.Context, *PaymentCancelRequest) error) *PaymentCancelLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *PaymentCancelLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *PaymentCancelLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *PaymentCancelLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *PaymentCancelLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *PaymentCancelLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *PaymentCancelLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *PaymentCancelLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *PaymentCancelLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestCheckoutClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows CheckoutWorkflows
}

var _ CheckoutClient = &TestCheckoutClient{}

// NewTestCheckoutClient initializes a new TestCheckoutClient value
func NewTestCheckoutClient(env *testsuite.TestWorkflowEnvironment, workflows CheckoutWorkflows, activities CheckoutActivities) *TestCheckoutClient {
	if workflows != nil {
		RegisterCheckoutWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterCheckoutActivities(env, activities)
	}
	return &TestCheckoutClient{env, workflows}
}

// CheckoutFlow executes a(n) temporal.Checkout.CheckoutFlow workflow in the test environment
func (c *TestCheckoutClient) CheckoutFlow(ctx context.Context, req *CheckoutFlowRequest, opts ...*CheckoutFlowOptions) (*Order, error) {
	run, err := c.CheckoutFlowAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CheckoutFlowAsync executes a(n) temporal.Checkout.CheckoutFlow workflow in the test environment
func (c *TestCheckoutClient) CheckoutFlowAsync(ctx context.Context, req *CheckoutFlowRequest, options ...*CheckoutFlowOptions) (CheckoutFlowRun, error) {
	var o *CheckoutFlowOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCheckoutFlowOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testCheckoutFlowRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetCheckoutFlow is a noop
func (c *TestCheckoutClient) GetCheckoutFlow(ctx context.Context, workflowID string, runID string) CheckoutFlowRun {
	return &testCheckoutFlowRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestCheckoutClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestCheckoutClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ CheckoutFlowRun = &testCheckoutFlowRun{}

// testCheckoutFlowRun provides convenience methods for interacting with a(n) temporal.Checkout.CheckoutFlow workflow in the test environment
type testCheckoutFlowRun struct {
	client    *TestCheckoutClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *CheckoutFlowRequest
	workflows CheckoutWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testCheckoutFlowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test temporal.Checkout.CheckoutFlow workflow result
func (r *testCheckoutFlowRun) Get(context.Context) (*Order, error) {
	r.env.ExecuteWorkflow(CheckoutFlowWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result Order
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test temporal.Checkout.CheckoutFlow workflow run's workflow ID
func (r *testCheckoutFlowRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testCheckoutFlowRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testCheckoutFlowRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testCheckoutFlowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// CheckoutCliOptions describes runtime configuration for temporal.Checkout cli
type CheckoutCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewCheckoutCliOptions initializes a new CheckoutCliOptions value
func NewCheckoutCliOptions() *CheckoutCliOptions {
	return &CheckoutCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *CheckoutCliOptions) WithAfter(fn func(*v2.Context) error) *CheckoutCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *CheckoutCliOptions) WithBefore(fn func(*v2.Context) error) *CheckoutCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *CheckoutCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *CheckoutCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *CheckoutCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *CheckoutCliOptions {
	opts.worker = fn
	return opts
}

// NewCheckoutCli initializes a cli for a(n) temporal.Checkout service
func NewCheckoutCli(options ...*CheckoutCliOptions) (*v2.App, error) {
	commands, err := newCheckoutCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "checkout",
		Commands: commands,
	}, nil
}

// NewCheckoutCliCommand initializes a cli command for a temporal.Checkout service with subcommands for each query, signal, update, and workflow
func NewCheckoutCliCommand(options ...*CheckoutCliOptions) (*v2.Command, error) {
	subcommands, err := newCheckoutCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "checkout",
		Subcommands: subcommands,
	}, nil
}

// newCheckoutCommands initializes (sub)commands for a temporal.Checkout cli or command
func newCheckoutCommands(options ...*CheckoutCliOptions) ([]*v2.Command, error) {
	opts := &CheckoutCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "checkout-flow",
			Usage:                  "executes a(n) temporal.Checkout.CheckoutFlow workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "general",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "cart",
					Usage:    "set the value of the operation's \"Cart\" parameter (json-encoded: {products: <temporal.Product>, total: <int32>, id: <string>})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "customer",
					Usage:    "set the value of the operation's \"Customer\" parameter (json-encoded: {id: <string>, name: <string>, phone: <string>, address: <temporal.Address>})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "payment-type",
					Usage:    "set the value of the operation's \"PaymentType\" parameter (CASH, ONLINE)",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewCheckoutClient(tc)
				req, err := UnmarshalCliFlagsToCheckoutFlowRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.CheckoutFlowAsync(cmd.Context, req, NewCheckoutFlowOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", CheckoutFlowWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a temporal.Checkout worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToCheckoutFlowRequest unmarshals a CheckoutFlowRequest from command line flags
func UnmarshalCliFlagsToCheckoutFlowRequest(cmd *v2.Context) (*CheckoutFlowRequest, error) {
	var result CheckoutFlowRequest
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("cart") {
		hasValues = true
		var v Cart
		if err := protojson.Unmarshal([]byte(cmd.String("cart")), &v); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"cart\" flag: %w", err)
		}
		result.Cart = &v
	}
	if cmd.IsSet("customer") {
		hasValues = true
		var v Profile
		if err := protojson.Unmarshal([]byte(cmd.String("customer")), &v); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"customer\" flag: %w", err)
		}
		result.Customer = &v
	}
	if cmd.IsSet("payment-type") {
		hasValues = true
		v, ok := PaymentType_value[cmd.String("payment-type")]
		if !ok {
			return nil, fmt.Errorf("unsupported enum value for \"payment-type\" flag: %q", cmd.String("payment-type"))
		}
		result.PaymentType = PaymentType(v)
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}
